// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RPC_MYIPC_H_
#define FLATBUFFERS_GENERATED_RPC_MYIPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace MyIPC {

struct AddRequest;
struct AddRequestBuilder;

struct AddResponse;
struct AddResponseBuilder;

struct RandRequest;
struct RandRequestBuilder;

struct RandResponse;
struct RandResponseBuilder;

struct Request;
struct RequestBuilder;

struct Response;
struct ResponseBuilder;

struct Root;
struct RootBuilder;

enum RequestBody : uint8_t {
  RequestBody_NONE = 0,
  RequestBody_AddRequest = 1,
  RequestBody_RandRequest = 2,
  RequestBody_MIN = RequestBody_NONE,
  RequestBody_MAX = RequestBody_RandRequest
};

inline const RequestBody (&EnumValuesRequestBody())[3] {
  static const RequestBody values[] = {
    RequestBody_NONE,
    RequestBody_AddRequest,
    RequestBody_RandRequest
  };
  return values;
}

inline const char * const *EnumNamesRequestBody() {
  static const char * const names[4] = {
    "NONE",
    "AddRequest",
    "RandRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestBody(RequestBody e) {
  if (::flatbuffers::IsOutRange(e, RequestBody_NONE, RequestBody_RandRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequestBody()[index];
}

template<typename T> struct RequestBodyTraits {
  static const RequestBody enum_value = RequestBody_NONE;
};

template<> struct RequestBodyTraits<MyIPC::AddRequest> {
  static const RequestBody enum_value = RequestBody_AddRequest;
};

template<> struct RequestBodyTraits<MyIPC::RandRequest> {
  static const RequestBody enum_value = RequestBody_RandRequest;
};

bool VerifyRequestBody(::flatbuffers::Verifier &verifier, const void *obj, RequestBody type);
bool VerifyRequestBodyVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ResponseBody : uint8_t {
  ResponseBody_NONE = 0,
  ResponseBody_AddResponse = 1,
  ResponseBody_RandResponse = 2,
  ResponseBody_MIN = ResponseBody_NONE,
  ResponseBody_MAX = ResponseBody_RandResponse
};

inline const ResponseBody (&EnumValuesResponseBody())[3] {
  static const ResponseBody values[] = {
    ResponseBody_NONE,
    ResponseBody_AddResponse,
    ResponseBody_RandResponse
  };
  return values;
}

inline const char * const *EnumNamesResponseBody() {
  static const char * const names[4] = {
    "NONE",
    "AddResponse",
    "RandResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseBody(ResponseBody e) {
  if (::flatbuffers::IsOutRange(e, ResponseBody_NONE, ResponseBody_RandResponse)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponseBody()[index];
}

template<typename T> struct ResponseBodyTraits {
  static const ResponseBody enum_value = ResponseBody_NONE;
};

template<> struct ResponseBodyTraits<MyIPC::AddResponse> {
  static const ResponseBody enum_value = ResponseBody_AddResponse;
};

template<> struct ResponseBodyTraits<MyIPC::RandResponse> {
  static const ResponseBody enum_value = ResponseBody_RandResponse;
};

bool VerifyResponseBody(::flatbuffers::Verifier &verifier, const void *obj, ResponseBody type);
bool VerifyResponseBodyVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Message : uint8_t {
  Message_NONE = 0,
  Message_Request = 1,
  Message_Response = 2,
  Message_MIN = Message_NONE,
  Message_MAX = Message_Response
};

inline const Message (&EnumValuesMessage())[3] {
  static const Message values[] = {
    Message_NONE,
    Message_Request,
    Message_Response
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[4] = {
    "NONE",
    "Request",
    "Response",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (::flatbuffers::IsOutRange(e, Message_NONE, Message_Response)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<MyIPC::Request> {
  static const Message enum_value = Message_Request;
};

template<> struct MessageTraits<MyIPC::Response> {
  static const Message enum_value = Message_Response;
};

bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct AddRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           verifier.EndTable();
  }
};

struct AddRequestBuilder {
  typedef AddRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(AddRequest::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(AddRequest::VT_Y, y, 0.0);
  }
  explicit AddRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddRequest> CreateAddRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0) {
  AddRequestBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct AddResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  double result() const {
    return GetField<double>(VT_RESULT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RESULT, 8) &&
           verifier.EndTable();
  }
};

struct AddResponseBuilder {
  typedef AddResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(double result) {
    fbb_.AddElement<double>(AddResponse::VT_RESULT, result, 0.0);
  }
  explicit AddResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddResponse> CreateAddResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double result = 0.0) {
  AddResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct RandRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RandRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RandRequestBuilder {
  typedef RandRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RandRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RandRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RandRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RandRequest> CreateRandRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RandRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RandResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RandResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  double result() const {
    return GetField<double>(VT_RESULT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RESULT, 8) &&
           verifier.EndTable();
  }
};

struct RandResponseBuilder {
  typedef RandResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(double result) {
    fbb_.AddElement<double>(RandResponse::VT_RESULT, result, 0.0);
  }
  explicit RandResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RandResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RandResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RandResponse> CreateRandResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double result = 0.0) {
  RandResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct Request FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BODY_TYPE = 4,
    VT_BODY = 6
  };
  MyIPC::RequestBody body_type() const {
    return static_cast<MyIPC::RequestBody>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const MyIPC::AddRequest *body_as_AddRequest() const {
    return body_type() == MyIPC::RequestBody_AddRequest ? static_cast<const MyIPC::AddRequest *>(body()) : nullptr;
  }
  const MyIPC::RandRequest *body_as_RandRequest() const {
    return body_type() == MyIPC::RequestBody_RandRequest ? static_cast<const MyIPC::RandRequest *>(body()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE, 1) &&
           VerifyOffset(verifier, VT_BODY) &&
           VerifyRequestBody(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const MyIPC::AddRequest *Request::body_as<MyIPC::AddRequest>() const {
  return body_as_AddRequest();
}

template<> inline const MyIPC::RandRequest *Request::body_as<MyIPC::RandRequest>() const {
  return body_as_RandRequest();
}

struct RequestBuilder {
  typedef Request Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_body_type(MyIPC::RequestBody body_type) {
    fbb_.AddElement<uint8_t>(Request::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(::flatbuffers::Offset<void> body) {
    fbb_.AddOffset(Request::VT_BODY, body);
  }
  explicit RequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Request> CreateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MyIPC::RequestBody body_type = MyIPC::RequestBody_NONE,
    ::flatbuffers::Offset<void> body = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

struct Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BODY_TYPE = 4,
    VT_BODY = 6
  };
  MyIPC::ResponseBody body_type() const {
    return static_cast<MyIPC::ResponseBody>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const MyIPC::AddResponse *body_as_AddResponse() const {
    return body_type() == MyIPC::ResponseBody_AddResponse ? static_cast<const MyIPC::AddResponse *>(body()) : nullptr;
  }
  const MyIPC::RandResponse *body_as_RandResponse() const {
    return body_type() == MyIPC::ResponseBody_RandResponse ? static_cast<const MyIPC::RandResponse *>(body()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE, 1) &&
           VerifyOffset(verifier, VT_BODY) &&
           VerifyResponseBody(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const MyIPC::AddResponse *Response::body_as<MyIPC::AddResponse>() const {
  return body_as_AddResponse();
}

template<> inline const MyIPC::RandResponse *Response::body_as<MyIPC::RandResponse>() const {
  return body_as_RandResponse();
}

struct ResponseBuilder {
  typedef Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_body_type(MyIPC::ResponseBody body_type) {
    fbb_.AddElement<uint8_t>(Response::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(::flatbuffers::Offset<void> body) {
    fbb_.AddOffset(Response::VT_BODY, body);
  }
  explicit ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Response> CreateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MyIPC::ResponseBody body_type = MyIPC::ResponseBody_NONE,
    ::flatbuffers::Offset<void> body = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

struct Root FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RootBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  MyIPC::Message message_type() const {
    return static_cast<MyIPC::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const MyIPC::Request *message_as_Request() const {
    return message_type() == MyIPC::Message_Request ? static_cast<const MyIPC::Request *>(message()) : nullptr;
  }
  const MyIPC::Response *message_as_Response() const {
    return message_type() == MyIPC::Message_Response ? static_cast<const MyIPC::Response *>(message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const MyIPC::Request *Root::message_as<MyIPC::Request>() const {
  return message_as_Request();
}

template<> inline const MyIPC::Response *Root::message_as<MyIPC::Response>() const {
  return message_as_Response();
}

struct RootBuilder {
  typedef Root Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type(MyIPC::Message message_type) {
    fbb_.AddElement<uint8_t>(Root::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(::flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Root::VT_MESSAGE, message);
  }
  explicit RootBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Root> CreateRoot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MyIPC::Message message_type = MyIPC::Message_NONE,
    ::flatbuffers::Offset<void> message = 0) {
  RootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyRequestBody(::flatbuffers::Verifier &verifier, const void *obj, RequestBody type) {
  switch (type) {
    case RequestBody_NONE: {
      return true;
    }
    case RequestBody_AddRequest: {
      auto ptr = reinterpret_cast<const MyIPC::AddRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RequestBody_RandRequest: {
      auto ptr = reinterpret_cast<const MyIPC::RandRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestBodyVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequestBody(
        verifier,  values->Get(i), types->GetEnum<RequestBody>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponseBody(::flatbuffers::Verifier &verifier, const void *obj, ResponseBody type) {
  switch (type) {
    case ResponseBody_NONE: {
      return true;
    }
    case ResponseBody_AddResponse: {
      auto ptr = reinterpret_cast<const MyIPC::AddResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ResponseBody_RandResponse: {
      auto ptr = reinterpret_cast<const MyIPC::RandResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponseBodyVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponseBody(
        verifier,  values->Get(i), types->GetEnum<ResponseBody>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Request: {
      auto ptr = reinterpret_cast<const MyIPC::Request *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Response: {
      auto ptr = reinterpret_cast<const MyIPC::Response *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const MyIPC::Root *GetRoot(const void *buf) {
  return ::flatbuffers::GetRoot<MyIPC::Root>(buf);
}

inline const MyIPC::Root *GetSizePrefixedRoot(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MyIPC::Root>(buf);
}

inline bool VerifyRootBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MyIPC::Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MyIPC::Root>(nullptr);
}

inline void FinishRootBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MyIPC::Root> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MyIPC::Root> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MyIPC

#endif  // FLATBUFFERS_GENERATED_RPC_MYIPC_H_
