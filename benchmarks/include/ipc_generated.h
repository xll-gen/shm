// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IPC_IPC_H_
#define FLATBUFFERS_GENERATED_IPC_IPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace ipc {

struct AddRequest;
struct AddRequestBuilder;

struct AddResponse;
struct AddResponseBuilder;

struct MyRandRequest;
struct MyRandRequestBuilder;

struct MyRandResponse;
struct MyRandResponseBuilder;

struct HeartbeatRequest;
struct HeartbeatRequestBuilder;

struct HeartbeatResponse;
struct HeartbeatResponseBuilder;

struct ShutdownRequest;
struct ShutdownRequestBuilder;

struct Message;
struct MessageBuilder;

enum Payload : uint8_t {
  Payload_NONE = 0,
  Payload_AddRequest = 1,
  Payload_AddResponse = 2,
  Payload_MyRandRequest = 3,
  Payload_MyRandResponse = 4,
  Payload_HeartbeatRequest = 5,
  Payload_HeartbeatResponse = 6,
  Payload_ShutdownRequest = 7,
  Payload_MIN = Payload_NONE,
  Payload_MAX = Payload_ShutdownRequest
};

inline const Payload (&EnumValuesPayload())[8] {
  static const Payload values[] = {
    Payload_NONE,
    Payload_AddRequest,
    Payload_AddResponse,
    Payload_MyRandRequest,
    Payload_MyRandResponse,
    Payload_HeartbeatRequest,
    Payload_HeartbeatResponse,
    Payload_ShutdownRequest
  };
  return values;
}

inline const char * const *EnumNamesPayload() {
  static const char * const names[9] = {
    "NONE",
    "AddRequest",
    "AddResponse",
    "MyRandRequest",
    "MyRandResponse",
    "HeartbeatRequest",
    "HeartbeatResponse",
    "ShutdownRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNamePayload(Payload e) {
  if (::flatbuffers::IsOutRange(e, Payload_NONE, Payload_ShutdownRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPayload()[index];
}

template<typename T> struct PayloadTraits {
  static const Payload enum_value = Payload_NONE;
};

template<> struct PayloadTraits<ipc::AddRequest> {
  static const Payload enum_value = Payload_AddRequest;
};

template<> struct PayloadTraits<ipc::AddResponse> {
  static const Payload enum_value = Payload_AddResponse;
};

template<> struct PayloadTraits<ipc::MyRandRequest> {
  static const Payload enum_value = Payload_MyRandRequest;
};

template<> struct PayloadTraits<ipc::MyRandResponse> {
  static const Payload enum_value = Payload_MyRandResponse;
};

template<> struct PayloadTraits<ipc::HeartbeatRequest> {
  static const Payload enum_value = Payload_HeartbeatRequest;
};

template<> struct PayloadTraits<ipc::HeartbeatResponse> {
  static const Payload enum_value = Payload_HeartbeatResponse;
};

template<> struct PayloadTraits<ipc::ShutdownRequest> {
  static const Payload enum_value = Payload_ShutdownRequest;
};

bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type);
bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct AddRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           verifier.EndTable();
  }
};

struct AddRequestBuilder {
  typedef AddRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(AddRequest::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(AddRequest::VT_Y, y, 0.0);
  }
  explicit AddRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddRequest> CreateAddRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0) {
  AddRequestBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct AddResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  double result() const {
    return GetField<double>(VT_RESULT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RESULT, 8) &&
           verifier.EndTable();
  }
};

struct AddResponseBuilder {
  typedef AddResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(double result) {
    fbb_.AddElement<double>(AddResponse::VT_RESULT, result, 0.0);
  }
  explicit AddResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddResponse> CreateAddResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double result = 0.0) {
  AddResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct MyRandRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MyRandRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MyRandRequestBuilder {
  typedef MyRandRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit MyRandRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MyRandRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MyRandRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MyRandRequest> CreateMyRandRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  MyRandRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MyRandResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MyRandResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  double result() const {
    return GetField<double>(VT_RESULT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RESULT, 8) &&
           verifier.EndTable();
  }
};

struct MyRandResponseBuilder {
  typedef MyRandResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_result(double result) {
    fbb_.AddElement<double>(MyRandResponse::VT_RESULT, result, 0.0);
  }
  explicit MyRandResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MyRandResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MyRandResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MyRandResponse> CreateMyRandResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double result = 0.0) {
  MyRandResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct HeartbeatRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeartbeatRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatRequestBuilder {
  typedef HeartbeatRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HeartbeatRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HeartbeatRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HeartbeatRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HeartbeatRequest> CreateHeartbeatRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HeartbeatResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeartbeatResponseBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HeartbeatResponseBuilder {
  typedef HeartbeatResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit HeartbeatResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HeartbeatResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HeartbeatResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HeartbeatResponse> CreateHeartbeatResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  HeartbeatResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ShutdownRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShutdownRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ShutdownRequestBuilder {
  typedef ShutdownRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ShutdownRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShutdownRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShutdownRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShutdownRequest> CreateShutdownRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ShutdownRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQ_ID = 4,
    VT_PAYLOAD_TYPE = 6,
    VT_PAYLOAD = 8
  };
  uint64_t req_id() const {
    return GetField<uint64_t>(VT_REQ_ID, 0);
  }
  ipc::Payload payload_type() const {
    return static_cast<ipc::Payload>(GetField<uint8_t>(VT_PAYLOAD_TYPE, 0));
  }
  const void *payload() const {
    return GetPointer<const void *>(VT_PAYLOAD);
  }
  template<typename T> const T *payload_as() const;
  const ipc::AddRequest *payload_as_AddRequest() const {
    return payload_type() == ipc::Payload_AddRequest ? static_cast<const ipc::AddRequest *>(payload()) : nullptr;
  }
  const ipc::AddResponse *payload_as_AddResponse() const {
    return payload_type() == ipc::Payload_AddResponse ? static_cast<const ipc::AddResponse *>(payload()) : nullptr;
  }
  const ipc::MyRandRequest *payload_as_MyRandRequest() const {
    return payload_type() == ipc::Payload_MyRandRequest ? static_cast<const ipc::MyRandRequest *>(payload()) : nullptr;
  }
  const ipc::MyRandResponse *payload_as_MyRandResponse() const {
    return payload_type() == ipc::Payload_MyRandResponse ? static_cast<const ipc::MyRandResponse *>(payload()) : nullptr;
  }
  const ipc::HeartbeatRequest *payload_as_HeartbeatRequest() const {
    return payload_type() == ipc::Payload_HeartbeatRequest ? static_cast<const ipc::HeartbeatRequest *>(payload()) : nullptr;
  }
  const ipc::HeartbeatResponse *payload_as_HeartbeatResponse() const {
    return payload_type() == ipc::Payload_HeartbeatResponse ? static_cast<const ipc::HeartbeatResponse *>(payload()) : nullptr;
  }
  const ipc::ShutdownRequest *payload_as_ShutdownRequest() const {
    return payload_type() == ipc::Payload_ShutdownRequest ? static_cast<const ipc::ShutdownRequest *>(payload()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REQ_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_PAYLOAD_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           VerifyPayload(verifier, payload(), payload_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ipc::AddRequest *Message::payload_as<ipc::AddRequest>() const {
  return payload_as_AddRequest();
}

template<> inline const ipc::AddResponse *Message::payload_as<ipc::AddResponse>() const {
  return payload_as_AddResponse();
}

template<> inline const ipc::MyRandRequest *Message::payload_as<ipc::MyRandRequest>() const {
  return payload_as_MyRandRequest();
}

template<> inline const ipc::MyRandResponse *Message::payload_as<ipc::MyRandResponse>() const {
  return payload_as_MyRandResponse();
}

template<> inline const ipc::HeartbeatRequest *Message::payload_as<ipc::HeartbeatRequest>() const {
  return payload_as_HeartbeatRequest();
}

template<> inline const ipc::HeartbeatResponse *Message::payload_as<ipc::HeartbeatResponse>() const {
  return payload_as_HeartbeatResponse();
}

template<> inline const ipc::ShutdownRequest *Message::payload_as<ipc::ShutdownRequest>() const {
  return payload_as_ShutdownRequest();
}

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_req_id(uint64_t req_id) {
    fbb_.AddElement<uint64_t>(Message::VT_REQ_ID, req_id, 0);
  }
  void add_payload_type(ipc::Payload payload_type) {
    fbb_.AddElement<uint8_t>(Message::VT_PAYLOAD_TYPE, static_cast<uint8_t>(payload_type), 0);
  }
  void add_payload(::flatbuffers::Offset<void> payload) {
    fbb_.AddOffset(Message::VT_PAYLOAD, payload);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t req_id = 0,
    ipc::Payload payload_type = ipc::Payload_NONE,
    ::flatbuffers::Offset<void> payload = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_req_id(req_id);
  builder_.add_payload(payload);
  builder_.add_payload_type(payload_type);
  return builder_.Finish();
}

inline bool VerifyPayload(::flatbuffers::Verifier &verifier, const void *obj, Payload type) {
  switch (type) {
    case Payload_NONE: {
      return true;
    }
    case Payload_AddRequest: {
      auto ptr = reinterpret_cast<const ipc::AddRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_AddResponse: {
      auto ptr = reinterpret_cast<const ipc::AddResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_MyRandRequest: {
      auto ptr = reinterpret_cast<const ipc::MyRandRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_MyRandResponse: {
      auto ptr = reinterpret_cast<const ipc::MyRandResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_HeartbeatRequest: {
      auto ptr = reinterpret_cast<const ipc::HeartbeatRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_HeartbeatResponse: {
      auto ptr = reinterpret_cast<const ipc::HeartbeatResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Payload_ShutdownRequest: {
      auto ptr = reinterpret_cast<const ipc::ShutdownRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPayloadVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPayload(
        verifier,  values->Get(i), types->GetEnum<Payload>(i))) {
      return false;
    }
  }
  return true;
}

inline const ipc::Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<ipc::Message>(buf);
}

inline const ipc::Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ipc::Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ipc::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ipc::Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ipc::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ipc::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ipc

#endif  // FLATBUFFERS_GENERATED_IPC_IPC_H_
